#!/bin/bash

# archy: Architecture documentation generator CLI wrapper
# Usage: 
#   archy fresh [-p project] [-f folder] [-d doc] [-n name] [-t tool]   - Create fresh architecture doc
#   archy update [-p project] [-f folder] [-d doc] [-t tool]           - Update from git changes
#   archy [file]                                              - Treat first arg as filename for update

set -euo pipefail

#================================================================
# CONFIGURATION
#================================================================
readonly SCRIPT_NAME="$(basename "$0")"
readonly DEFAULT_ARCH_FILENAME="arch.md"
readonly DEFAULT_PROJECT_PATH="."

# Supported AI backends
readonly SUPPORTED_BACKENDS=("cursor-agent" "fabric" "cursor")

# Command aliases for different modes
readonly FRESH_COMMAND_ALIASES=("fresh" "create" "new" "--fresh")
readonly UPDATE_COMMAND_ALIASES=("update" "--update")
readonly TEST_COMMAND_ALIASES=("test" "--test")
readonly HELP_COMMAND_ALIASES=("-h" "--help" "help")

#================================================================
# GLOBAL VARIABLES
#================================================================
# Script and path resolution (set in resolve_script_location)
SCRIPT_DIR=""
ARCH_SCRIPT_PATH=""

# Command execution parameters (set in parse_command_flags)
COMMAND_MODE=""
PROJECT_PATH=""
SUBFOLDER=""
ARCH_FILENAME=""
PROJECT_NAME=""
AI_BACKEND=""

#================================================================
# UTILITY FUNCTIONS
#================================================================

# Print error message and exit
error_exit() {
    local message="$1"
    local exit_code="${2:-1}"
    
    echo "‚ùå ERROR: $message" >&2
    exit "$exit_code"
}

# Print informational message
info() {
    local message="$1"
    echo "‚ÑπÔ∏è  $message"
}

# Print success message
success() {
    local message="$1"
    echo "‚úÖ $message"
}

# Print command execution header
print_command_header() {
    local mode="$1"
    local icon="$2"
    
    echo "$icon $mode architecture documentation..."
    echo "   Project: ${PROJECT_PATH:-$DEFAULT_PROJECT_PATH}"
    echo "   Folder: ${SUBFOLDER:-"(root)"}"
    echo "   File: ${ARCH_FILENAME:-$DEFAULT_ARCH_FILENAME}"
    echo "   AI Backend: ${AI_BACKEND:-"${ARCHY_AI_BACKEND:-cursor-agent}"}"
    
    if [[ -n "$PROJECT_NAME" ]]; then
        echo "   Name: $PROJECT_NAME"
    else
        echo "   Name: (auto-detect)"
    fi
}

#================================================================
# SCRIPT LOCATION AND SETUP FUNCTIONS
#================================================================

# Resolve symlinks to find the actual arch.sh script location
resolve_script_location() {
    local script_path="$0"
    
    # Handle symlink resolution to find the real arch.sh location
    if [[ -L "$script_path" ]]; then
        local real_script
        real_script="$(readlink "$script_path")"
        
        if [[ "$real_script" = /* ]]; then
            # Absolute path
            SCRIPT_DIR="$(dirname "$real_script")"
        else
            # Relative path - resolve relative to the symlink location
            SCRIPT_DIR="$(cd "$(dirname "$script_path")" && cd "$(dirname "$real_script")" && pwd)"
        fi
    else
        # Not a symlink - use directory of current script
        SCRIPT_DIR="$(cd "$(dirname "$script_path")" && pwd)"
    fi
    
    # Construct path to the main arch.sh script
    ARCH_SCRIPT_PATH="$SCRIPT_DIR/arch.sh"
    
    # Verify the arch.sh script exists
    if [[ ! -f "$ARCH_SCRIPT_PATH" ]]; then
        error_exit "Cannot find arch.sh script at: $ARCH_SCRIPT_PATH"
    fi
}

#================================================================
# SECURITY VALIDATION FUNCTIONS
#================================================================

# Basic path traversal protection for user inputs
validate_path_security() {
    local path="$1"
    
    # Prevent directory traversal attacks (e.g., ../../../etc/passwd)
    if [[ "$path" =~ \.\./|\.\.\\ ]] || [[ "$path" =~ /\.\./|/\.\.\\ ]]; then
        error_exit "Path traversal detected: $path"
    fi
}

# Validate filename contains only safe characters
validate_filename_security() {
    local filename="$1"
    
    # Only allow alphanumeric characters, dots, underscores, and hyphens
    if [[ ! "$filename" =~ ^[a-zA-Z0-9._-]+$ ]]; then
        error_exit "Invalid characters in filename: $filename"
    fi
}

# Validate AI backend is supported
validate_ai_backend() {
    local backend="$1"
    
    local supported_backend
    for supported_backend in "${SUPPORTED_BACKENDS[@]}"; do
        if [[ "$backend" == "$supported_backend" ]]; then
            return 0
        fi
    done
    
    error_exit "Invalid AI backend '$backend'. Supported: ${SUPPORTED_BACKENDS[*]}"
}

#================================================================
# COMMAND FLAG PARSING FUNCTIONS
#================================================================

# Parse command line flags for fresh/update modes
parse_command_flags() {
    local mode="$1"
    shift
    
    # Set defaults
    PROJECT_PATH="$DEFAULT_PROJECT_PATH"
    SUBFOLDER=""
    ARCH_FILENAME="$DEFAULT_ARCH_FILENAME"
    PROJECT_NAME=""
    AI_BACKEND=""
    
    # Parse command line flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--project)
                PROJECT_PATH="$2"
                shift 2
                ;;
            -f|--folder)
                SUBFOLDER="$2"
                shift 2
                ;;
            -d|--doc)
                ARCH_FILENAME="$2"
                shift 2
                ;;
            -n|--name)
                PROJECT_NAME="$2"
                shift 2
                ;;
            -t|--tool)
                AI_BACKEND="$2"
                shift 2
                ;;
            -h|--help)
                show_help_message
                exit 0
                ;;
            *)
                error_exit "Unknown flag: $1. Use -h for help."
                ;;
        esac
    done
    
    # Validate all user inputs for security
    validate_all_command_inputs
    
    # Set AI backend environment variable if specified
    if [[ -n "$AI_BACKEND" ]]; then
        export ARCHY_AI_BACKEND="$AI_BACKEND"
    fi
    
    # Execute the appropriate command
    execute_architecture_command "$mode"
}

# Validate all command inputs for security and correctness
validate_all_command_inputs() {
    validate_path_security "$PROJECT_PATH"
    
    if [[ -n "$SUBFOLDER" ]]; then
        validate_path_security "$SUBFOLDER"
    fi
    
    validate_filename_security "$ARCH_FILENAME"
    
    if [[ -n "$AI_BACKEND" ]]; then
        validate_ai_backend "$AI_BACKEND"
    fi
}

# Execute the architecture generation command with the parsed parameters
execute_architecture_command() {
    local mode="$1"
    
    if [[ "$mode" == "fresh" ]]; then
        print_command_header "Creating" "üèóÔ∏è "
        execute_fresh_mode_command
    else
        print_command_header "Updating" "üîÑ"
        execute_update_mode_command
    fi
}

# Execute fresh mode architecture generation
execute_fresh_mode_command() {
    local cmd_args=("$ARCH_SCRIPT_PATH" "--fresh" "$PROJECT_PATH" "$SUBFOLDER" "$ARCH_FILENAME")
    
    if [[ -n "$PROJECT_NAME" ]]; then
        cmd_args+=("$PROJECT_NAME")
    fi
    
    exec "${cmd_args[@]}"
}

# Execute update mode architecture generation
execute_update_mode_command() {
    exec "$ARCH_SCRIPT_PATH" "$PROJECT_PATH" "$SUBFOLDER" "$ARCH_FILENAME"
}

#================================================================
# AI BACKEND TESTING FUNCTIONS
#================================================================

# Test AI backend functionality with optional custom message
test_ai_backend_connectivity() {
    local backend_to_test=""
    local test_message=""
    
    # Parse test command flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            -t|--tool)
                backend_to_test="$2"
                shift 2
                ;;
            *)
                test_message="$1"
                shift
                ;;
        esac
    done
    
    # Validate and set backend if specified
    if [[ -n "$backend_to_test" ]]; then
        validate_ai_backend "$backend_to_test"
        export ARCHY_AI_BACKEND="$backend_to_test"
    fi
    
    # Execute the AI backend test script
    local test_script_path="$SCRIPT_DIR/test_ai_backend.sh"
    
    if [[ -n "$test_message" ]]; then
        exec "$test_script_path" "$test_message"
    else
        exec "$test_script_path"
    fi
}

#================================================================
# HELP AND USAGE FUNCTIONS
#================================================================

# Display comprehensive help message
show_help_message() {
    cat << EOF
archy: üèõÔ∏è Architecture documentation generator using AI backends (cursor-agent, fabric) üèõÔ∏è

Usage:
  archy fresh [-p project] [-f folder] [-d doc] [-n name] [-t tool]
  archy update [-p project] [-f folder] [-d doc] [-t tool]
  archy test [-t tool] [message]      # Test AI backend (cursor-agent|fabric)
  archy [filename]                    # Legacy: treat as update with filename

Flags:
  -p, --project PATH    Git project path (for fresh/update commands)
  -t, --tool NAME       AI tool (cursor-agent|fabric)
  -f, --folder PATH     Subfolder to focus on (optional)
  -d, --doc FILE        Documentation filename (default: $DEFAULT_ARCH_FILENAME)
  -n, --name NAME       Project name (default: auto-detect from folder)
  -h, --help            Show this help

Examples:
  archy test                               # Test cursor-agent (default)
  archy test -t fabric                     # Test fabric backend
  archy test -t cursor "Custom message"    # Test cursor-agent with custom message
  archy fresh                              # Create $DEFAULT_ARCH_FILENAME in current dir
  archy fresh -t fabric                    # Create with fabric backend
  archy fresh -f backend -d api.md         # Focus on backend/, output to api.md
  archy fresh -p /path/to/repo -n MyApp -t fabric  # Different project with fabric
  archy update -f frontend                 # Update focusing on frontend/
  archy update -t fabric                   # Update with fabric backend
  archy update -p ../other-repo -t cursor  # Update different project with cursor-agent

Environment variables (for fresh/update commands):
  ARCHY_AI_BACKEND=cursor-agent            # Use cursor-agent (default)
  ARCHY_AI_BACKEND=fabric                  # Use fabric (supports local models)

Legacy compatibility:
  archy some-file.md                       # Treats as: archy update -d some-file.md
EOF
}

#================================================================
# COMMAND ROUTING FUNCTIONS
#================================================================

# Check if command matches any of the provided aliases
command_matches_aliases() {
    local command="$1"
    shift
    local aliases=("$@")
    
    local alias
    for alias in "${aliases[@]}"; do
        if [[ "$command" == "$alias" ]]; then
            return 0
        fi
    done
    return 1
}

# Handle legacy mode for backward compatibility
handle_legacy_mode() {
    local filename="$1"
    
    info "Updating architecture documentation (legacy mode)..."
    echo "   Directory: $(pwd)"
    echo "   File: $filename"
    
    exec "$ARCH_SCRIPT_PATH" . "" "$filename"
}

# Route command to appropriate handler based on command type
route_command() {
    local command="${1:-help}"
    shift
    
    if command_matches_aliases "$command" "${FRESH_COMMAND_ALIASES[@]}"; then
        parse_command_flags "fresh" "$@"
        
    elif command_matches_aliases "$command" "${UPDATE_COMMAND_ALIASES[@]}"; then
        parse_command_flags "update" "$@"
        
    elif command_matches_aliases "$command" "${TEST_COMMAND_ALIASES[@]}"; then
        test_ai_backend_connectivity "$@"
        
    elif command_matches_aliases "$command" "${HELP_COMMAND_ALIASES[@]}"; then
        show_help_message
        
    else
        # Check for legacy mode: filename with architecture-like extension
        if [[ "$command" =~ \.(md|txt|rst)$ ]] || [[ "$command" == *"arch"* ]]; then
            handle_legacy_mode "$command"
        else
            error_exit "Unknown command: $command. Use -h for help."
        fi
    fi
}

#================================================================
# MAIN EXECUTION FUNCTION
#================================================================

# Main entry point - coordinates all script operations
main() {
    # Initialize script environment
    resolve_script_location
    
    # Route to appropriate command handler
    route_command "$@"
}

#================================================================
# SCRIPT ENTRY POINT
#================================================================

# Execute main function with all command line arguments
main "$@"
